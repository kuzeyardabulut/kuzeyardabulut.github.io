[ { "title": "Trying to Enable KCOV on Samsung Galaxy S22", "url": "/posts/FuzzS22/", "categories": "Fuzzing, Android Kernel", "tags": "fuzzing, samsung, s22, kcov", "date": "2024-04-08 12:00:00 +0300", "snippet": "In this article, I will talk about the research I did by spending about 1.5 months on the S22 device. The primary purpose of my research was to fuzz the device by compiling the kernel with KCOV, but unfortunately, I could not succeed as a result of my many attempts. In the rest of our article, I will explain the experiments I made respectively.First I downloaded the firmware of the device from SAMFW, then I downloaded the kernel code of the device from Samsung Opensource and started working.Enable KCOVAfter downloading the code to my local, I first bought a clean build and flashed it to the device. Everything worked as it should. Then I enabled KCOV on the kernel config and flashed it to the device and I got bootloop. At that point, I started thinking about what was holding me back.Setting propsThe first thing that came to my mind afterwards was of course to think that it was the security features inside the device. From this point of view, the first thing I tried to do was to change the device’s props. For this I unpacked vendor_boot.img with Magisk, then I changed ro.selinux and all the other props that I thought were related to the security features but unfortunately it didn’t help me.Trying to debug the deviceWe had a kernel image that did not boot when flashed. Then I thought about getting a log file and started looking for the log files on the system one by one, scrutinizing them to make sure I didn’t miss a single log.But what I was ignoring is this:Since the device was not booting, naturally it was not creating a log file anywhere. Because the problem was the PKM of RKP feature. I will talk about this in the future.At this step, I started to think to myself that I should come up with a solution. In this step, I wrote a code to log to /data/tmp/local in a function that runs when the kernel first boots and is called again at certain intervals. Here, too, I incurred the wrath of SELinux…Even though I turned off SELinux through its props, it remained enforced during boot. Even though SELinux was permissive after boot, it didn’t work.(NOTE: The function was called even when SELinux was permissive but SELinux prevented the write with a warning).In this strange situation, I had to write a custom SELinux policy. I wrote this policy too, but even though it created the file, the write operation never happened.  RKPI mentioned that I couldn’t get any logs from the device so far, and I didn’t have a chance to open the phone and connect it to the UART. In this context, I started to analyze the device by trial and error.First of all, to debug KCOV, I found all the code fragments that were added and removed when KCOV was opened in the kernel code. Then I deleted and compiled all the code fragments of KCOV. What I wanted to understand here was to understand whether the security feature on the device read the .config file and blocked us. Of course, it was not blocking us by reading the .config.After that, I started to enable the code pieces step by step and I realized the following:Every time I added or removed an element to the struct named task_struct, the kernel would bootloop. KCOV was a config that added elements to this task_struct. When I realized this, the first thing that came to my mind was that some code was hardcoded according to the size of the task_struct and therefore there was a shift in some casting operations. This slippage was crashing us.But of course, this was not the case, there were two reasons for this:1) We were also crashing when we added an element at the bottom of the task_struct. 2) Inside the task_struct, variables were pointing to a struct. I defined variables under these structs read the code that used this struct and made sure that I would not cause any crash (we examined it in detail to make sure that we would not cause any kernel BUGs), but it still did not boot.At this stage, I realized that there was a security feature that prevented the following;adding elements to task_struct,Adding elements to structs under task_struct.But this seemed ridiculous to me. Yes, I couldn’t define a variable inside a task_struct, but why can’t I define a variable inside a struct pointed to by a variable inside a task_struct!!!!So I made one last attempt and tried to find all the structs that have pointers under task_struct and add elements to the bottom of each one.pi_state_cache, rcu_node, futex_pi_state ------&amp;gt; I was successful with these three structs.In other words, I could add variables to these structs as I wanted. In this way, instead of defining the elements that KCOV uses directly under task_struct, I would define them in one of these structs. Then, with some minor changes to the kcov file, I would have successfully compiled kcov.Custom KCOVAs I mentioned in the previous section, I adapted the struct named futex_pi_state to kcov.When I ran the file compiled with this kcov.c, I got bootloop again. The reason for this was symbols as far as I researched. RKP was somehow examining the symbols in the kernel image and blocking us. But I couldn’t find any conclusive evidence for this.And at this step, I thought the only solution was to try to turn off RKP.Trying to turn off security features (e.g. RKP, selinux…) via kernel codeTo make SELinux permissive permanently in the kernel code, we need to edit the kernel_platform/common/security/selinux/selinuxfs.c file, where we need to make the following changes:Lines 152-178 below://CUT/* No partial writes. */    if (*ppos != 0)        return -EINVAL;    page = memdup_user_nul(buf, count);    if (IS_ERR(page))        return PTR_ERR(page);    length = -EINVAL;    if (sscanf(page, &quot;%d&quot;, &amp;amp;new_value) != 1)        goto out;    new_value = !!new_value;    old_value = enforcing_enabled(state);    new_value = 0; //ADD FOR PERMANENT PERMESSIVE    if (new_value != old_value) {        length = avc_has_perm(&amp;amp;selinux_state,                      current_sid(), SECINITSID_SECURITY,                      SECCLASS_SECURITY,     //CUT The following link is useful for turning off Knox and RKP security features:https://github.com/jgudec/android_kernel_samsung_exynos2200/commit/f70a029cc517115a8dc6a34955dbacb17a4e1446I made all these changes normally and the device booted without KCOV. Then I enabled KCOV and failed. I believe that the reason for this is the PKM, which is a security feature under the RKP. It blocks to change kernel code.Turning off RKP in Config does not mean turning off the RKP on the CPU." }, { "title": "AWS Certified Security - Specialty (SCS-C01) Exam Experiences", "url": "/posts/AWS_Speciality/", "categories": "AWS, Cloud Security", "tags": "security specialty, aws exam, result, guide", "date": "2023-06-17 00:21:00 +0300", "snippet": "I passed the AWS Security Specialty exam about 6 months ago and became the world’s youngest aws expert at the age of 15. Today I would like to tell you about my experience in this difficult process.What is AWS Security Specialty?The AWS Security Specialty exam is one of the most difficult AWS exams dealing with cloud security. In this exam, you are held responsible for 6 different domains. You are expected to have detailed information about these domains and to answer any questions asked about these domains. You can get detailed information about these domains here.Exam Procedures This exam takes 170 minutes. If you’re a non-native English speaker then you can request +30 minutes extra to complete the exam. The minimum passing score is 750 points. It costs 300 USD. If you have a voucher then it can be cheaper.How I Got Interested in AWS Security Specialty?Cyber ​​security is an area that I have been working on for a long time and made a lot of progress in this area, but I had never had experience in cloud security before. One day I saw my friends at the office chatting about cloud security. After that, I searched for a good roadmap myself to learn cloud security and found this exam. So I set myself this exam as my goal to learn.My Preparation ProcessI too have seen many intimidating articles and comments about the exam before I went into the exam preparation process. But my experience is definitely not like that. I think the exam preparation process was fun and unusual. As someone who is familiar with cyber security, some subjects were really easy for me, but some subjects are just as difficult. I learned a lot about DevOps, especially during the exam preparation process. What I learned has broadened my security perspective.The most challenging process in this exam was studying. During this process, I received help from many sources. Especially Udemy Courses and AWS Documents helped me a lot. I highly recommend reading the AWS documentation. While reading these, definitely don’t forget to take notes regularly with an application like Notion.Exam ResultI took the exam the day before my birthday. I had many problems before I took the exam. (such as the application freezing and not taking you to the exam for 1 hour) Although these problems annoyed me a lot, I focused on the exam and answered the questions. When I came out of the exam, I thought I had failed. The next day, the exam result is announced. I didn’t want to look at my test result first. Later, my mentor Güray looked at my exam result and said that I passed the exam with 850 points out of 1000. Thus, at the age of 15, I received this certificate and became the youngest AWS expert in the world.While preparing for the exam, I read comments on many blogs that this exam requires 5-6 years of experience. I strongly advise you not to believe them. It’s a test you can pass if you study hard enough and want to.ConclusionBecoming the youngest AWS Security Specialist in the world has been a source of inspiration, not just for myself, but also for other young professionals considering a path in this field. This experience has demonstrated the importance of hard work, perseverance, and maintaining focus on a goal.The AWS Security Specialty certification is a highly demanded skill in an era where security in cloud technologies plays a vital role. This certification will solidify your place in the industry and provide you with a significant competitive advantage.Lastly, I wish each of you success in your AWS Security Specialty journey. Perhaps one day, someone else will read this blog and be inspired to write their own success story." }, { "title": "DLL Hollowing with Rust Language: Stealth Injection", "url": "/posts/RustStomping/", "categories": "Malware, Windows Injection, Rust", "tags": "malware, windows, dll hollowing, rust", "date": "2023-06-11 00:21:00 +0300", "snippet": "This will be the first blog on this website. I take DLL Hollowing topic for my first blog because I didn’t see any articles about DLL Hollowing with rust-lang so I decided to talk about that. This project is a bit different than others because we are not creating threads. We are just changing the active module’s permissions and injecting our shellcode to this module without changing headers. When this shellcode is executed, it will load your DLL and create your real target process.Just before starting you can access my codes in here.RequirementsFor this setup, you will need the following: Rust Programming Language (https://www.rust-lang.org/) DLL Hollowing Project (https://github.com/kuzeyardabulut/rust-dll-hollowing)SetupFirst, you should clone this repository then you will compile the codes like below:cd rust-dll-hollowingcargo build --releaseNow we compile this project but we need a shellcode that is going to call the LoadLibrary function. For creating a shellcode, we are going to use msfvenom. Execute the following commands in your bash terminal.msfvenom -p windows/x64/loadlibrary DLL=C:\\\\Users\\\\Public\\\\in.dll PrependMigrate=true PrependMigrateProc=explorer.exe -f rust ‐-bad-chars &#39;\\x00\\x0a\\x0d&#39;If you successfully complete all of these steps then you are ready!Injection MethodWhen you read the well-known Windows Injection Methods, you can see many methods for malware development and game cheats. You can run your DLLs in many ways, but when loading or running those DLLs, your injectors should be undetectable. In general, many basic and known injection methods can be detected by antis.Figure 1: Generally Known Injection MethodsTherefore, attackers usually try to make them undetectable by making minor changes to known methods and this makes the job of cyber security experts difficult. For this, I will describe a method that I have differentiated by changing it so that cybersecurity experts can better understand the attackers’ perspective.Module Stomping OverviewModule Stomping is a well-known injection method. In this technique, you are injecting your shell code under your Legit DLL. This way, your shellcode will run under the Legit DLL.First, your injector allocates space with VirtualAllocEx function then it will write your DLL’s path to allocated space with WriteProcessMemory function for loading your Legit DLL (for example: kernel32.dll, amsi.dll) to your target process. After that, the injector calls CreateRemoteThread function for creating threads. If the injector is successful to create a thread then it will suspend the thread. After all that, the injector will calculate the target Legit DLLs AddressOfEntryPoint (points to the beginning of the .text section) and will write your shellcode to that calculated address. VirtualAllocEx: It allocates space under the region of memory within the virtual address space of a specified process. If the target address is null, the function determines where to allocate the region. WriteProcessMemory: The entire field to be written must be accessible and free, otherwise the operation will fail. AddressOfEntryPoint: The AddressOfEntryPoint is a specific memory address within an executable file where the execution of the program begins after it is loaded into memory. It serves as the entry point for the operating system to start executing the program’s instructions. We are going to calculate this address from NT Headers in Code Review part of our article. CreateRemoteThread: The CreateRemoteThread is a function in the Windows operating system that allows a process to create a thread in a different process, enabling it to execute code in the context of that remote process. ResumeThread: ResumeThread is a function in Windows operating systems that allows a suspended thread to resume execution.At this stage, we have completed all our injection processes, we just need to change the Suspend state of our thread using the ResumeThread function. Once finished, your shellcode will run under a Legal DLL. The headers of these Legitimate DLLs will remain the same, thus making it difficult for malicious shellcodes to be detected.Figure 2: Shellcode is running under the amsi.dllPros And Cons Of The Module StompingAs with any method, this method has its pros and cons. As with any method, this method has its pros and cons. The pros and cons of the techniques are usually examined by cybersecurity experts and appropriate detectors are coded.Pros: Your Shellcode is running under a Legit DLL. This makes it less likely to be detected. You don’t need to use a VirtualProtectEx again as you have granted the permissions appropriately to write the shellcode when allocating the space. Since you do the injection operations while the thread is suspended, the probability of detection may decrease.Cons: You load a Legit DLL into a Legit Process. This may sound normal at first, but we should not forget that our injector, which is a non-Legit process, is trying to do all this, and many functions (VirtualAllocEx, CreateRemoteThread…) are used while the injector is doing all this. An extra and unusual thread is created in the process.AddressOfEntryPoint Injection OverviewAddressOfEntryPoint Injection is a bit different than Module Stomping because when you’re doing that injection method you don’t need to Allocate any space from memory and you don’t need to create or suspend your threads. You can write shellcode directly by changing the permissions to the existing module.You can review this techniques code in the Code Review section of our article.First, you must set a target module. it may be better if this module does not run as a thread. Secondly, you should check the module’s permissions. If the module’s permission of the checked module is not PAGE_EXECUTE_READWRITE then change the permission of the module with the VirtualProtectEx function. Secondly, read the process memory with ReadProcessMemory function then calculate the NTHeaders with return values. Then calculate AddressOfEntryPoint from NTHeaders. After all, write your shellcode to AddressOfEntryPoint address (start of the .text section) with WriteProcessMemory function, and your injection process is done. Now your shellcode will run when the process tries to use the module whose shellcode you inject.Figure 3: Shellcode injected to urlmon.dllPros And Cons Of The AddressOfEntryPoint InjectionThis method also has pros and cons compared to module stomping.Pros: Your Shellcode is running under a Legit DLL. This makes it less likely to be detected. You don’t need to use a VirtualAllocate. You don’t need to load Legit DLL first. You don’t need to create a thread.Cons: You need to change the permission of the existing module. You are going to change the running modules’ permission.Code ReviewAfter talking about the similarities of the techniques, we can now move on to the review part of our code.When we first look at our Workspace from Github, we see two different projects named “encrypt shellcode” and “injector”. The “encrypt shellcode” project encrypts our shellcode and prints us this encrypted shellcode. You can review it by yourself. The “injector” project is our AddressOfEntryPoint Injector. So we are going to review the “injection” project in this article.main.rsIn main file, we are completing all of the Injection things. Now i will explain the code pieces one by one. Let’s Start !At the beginning of the file, the necessary libraries are imported, const variables are determined, and a macro named print_permission is written. Let’s start by explaining the variables first. These variables are named BUF and TARGET_PROCESS_NAME. TARGET_PROCESS_NAME contains the name of the process where the shellcode will be injected. BUF is the encrypted version of your shellcode. If we look at our macro, this macro tries to change the permissions of the target module using the VirtualProtectEx function.Figure 4: Head of main.rsNow, we have a function whose name is everything. In this function, we are decoding your AES-encrypted shellcode with our functions.Figure 5: everythingHere we are starting the Injection! First, we are getting the target processes ID by processes name. After that, we are getting the module’s base address and we are opening the target process with OpenProcess function. Then we are saving the process handle and calculate the MEMORY_BASIC_INFORMATION.Figure 6: Calculating the MemoryInfoWe are getting MEMORY_BASIC_INFORMATION from the module’s base address with VirtualQueryEx function. Then we try to control the memory protections and change the memory protections with the print permission function, which is the function we mentioned at the beginning. After that we are getting memory pieces of information with ReadProcessMemory function to calculate AddressOfEntryPoint.Figure 7: Change Permission and Get MemoryInfoWe read the memory and got DOS_HEADERS. If we want to get AddressOfEntity we need to calculate NT_HEADERS. If we want to calculate NT_HEADERS we should use e_lfanew which is under DOS_HEADER. e_lfanew: This is the member of the DOS header structure within a PE (Portable Executable) file. This member is a 32-bit signed integer located at offset 0x3C (60 decimal) in the DOS header. “e_lfanew” specifies the offset from which the NT (New Technology) headers start in the file. The PE loader uses the value within “e_lfanew” to locate the beginning of the NT headers and then parse the file header to understand the structure of the executable file. This value is important for the loader because it determines where to look for the file header.So we will collect the base address with e_lfanew and find the starting address of NT_HEADERS. When we find the NT_HEADERS, we will calculate the AddressOfEntryPoint. After that we will be summing the base address and the AddressOfEntryPoint we will get the beginning of the .text section.We will print out the important addresses which we found and write our shellcode to memory with the WriteProcessMemory function from where the .text section starts.Figure 8: Write Your ShellcodeWhen your module will be used, the shellcode will work on your target machine. This way the shellcode will run under the Legit DLL, making it harder to detect. Let’s look at security.rs to see Security Protections.security.rsNow, we will review our security protections. First, we are importing our libraries. Then we are writing a function whose name is anti_debugger. This function checks if the debugger is running so that the binary is not examined by the debugger.Figure 9: Checks DebuggerAfter checking the debugger, we are actively checking the processes running in the system. If some unwanted processes are running, we close the program without injection.Figure 10: Checking ProcessesYou can see the unwanted process list below. Also, you can add some process names as unwanted.Figure 11: Unwanted Processes Listsencrypt.rsShellcodes created with msfvenom and embedded in the project can be easily understood by antiviruses. However, if these shellcodes are encoded, it becomes almost impossible to find them in static analysis.So we will encrypt our shellcode with encrypt_shellcode project. Then we will embed our encrypted shellcode into Injector project. When the program starts the main function will call decoder with keys. After that, the decoder will receive encrypted shellcode and checks the shellcode_len. If it is bigger than 516 bytes then it will receive first 516 byte and will decode this 516 byte. After that, it will subtract 516 bytes, which is the space we solved earlier in the size of the file. If the Remaining area is greater than 516 it will be continued in the same way. When space is less than 516 bytes, all remaining space regardless of space will be read and decoded.Figure 12: Shellcode DecoderConclusionAs a result, in this article, we examined DLL injection methods and examined AddressOfEntryPoint Injector that we developed with Rust. We’ve explained the important pieces of code inside main.rs. You can see other codes from my Github. If there is a piece of code that you do not understand, you can reach me on my social media addresses.Thanks for reading." }, { "title": "The Difficulty of Reverse Engineering Applications Written in Rust", "url": "/posts/ReverseRust/", "categories": "Rust, Memory Safety, Reverse Engineering", "tags": "rust, reverse engineering", "date": "2023-05-29 00:21:00 +0300", "snippet": "Reverse engineering is the process of analyzing a software application to understand its inner workings and functionality. It’s usually done for a variety of reasons, such as understanding undocumented systems, detecting vulnerabilities, or creating compatible software. But reverse engineering becomes quite challenging when it comes to applications written in Rust. This article aims to explain the reasons behind the difficulty of reverse engineering Rust applications.Memory Safety and Ownership ModelRust is a systems programming language that prioritizes memory safety and eliminates common programming errors like null pointer dereferences, buffer overflows, and data races. This is achieved through its unique ownership model and borrow checker, which enforces strict rules on how data is accessed and modified. As a result, Rust programs are inherently more resilient against memory-related vulnerabilities and exploitation.When reverse engineering a Rust application, understanding the ownership model and reconstructing the memory layout becomes essential. Rust’s memory management techniques, such as stack and heap allocations, lifetimes, and borrowing, are complex to decipher without the source code. Reverse engineers need to reconstruct these ownership relationships and memory management patterns accurately, which can be time-consuming and error-prone.Abstraction and Compiler OptimizationsRust provides high-level abstractions without compromising performance. It offers powerful features like pattern matching, algebraic data types, and iterators, which enable expressive and concise code. However, these abstractions are compiled down to low-level machine code, making it challenging to trace back the original intent from the compiled binary.Furthermore, the Rust compiler applies aggressive optimizations to generate efficient code. These optimizations include inlining functions, eliminating dead code, and reordering instructions. While these optimizations enhance performance, they also obfuscate the binary, making it harder to understand the control flow, variable assignments, and function boundaries during reverse engineering.Strong Type System and EnumerationsRust employs a strong type system that ensures memory safety and prevents type-related errors. The type system is expressive and allows developers to define complex data structures using enumerations (enums). Enums are particularly challenging to reverse engineer because they can represent different states and variations of data within a single type.Deciphering the meaning and purpose of enums in a Rust binary requires extensive analysis of memory layouts, function calls, and control flow. Reverse engineers need to identify the different enum variants, understand the associated data, and reconstruct their relationships accurately.Lack of Symbolic InformationSymbolic information, such as function names, variable names, and data structures, is crucial for understanding the behavior of a program during reverse engineering. However, Rust’s default compilation process, known as “stripping symbols,” removes most of this information from the compiled binary. This significantly hampers the reverse engineer’s ability to comprehend the code’s intent, leading to a more challenging and time-consuming reverse engineering process.Reverse engineers often rely on dynamic analysis techniques like debugging and dynamic binary instrumentation to extract symbolic information from a running program. However, even with these techniques, reconstructing high-level abstractions and program logic from a Rust binary remains considerably difficult.ConclusionReverse engineering applications written in Rust present unique challenges because of the language’s emphasis on memory safety, type system, and lack of symbolic information. The ownership pattern, compiler optimizations, strong type system, and stripped symbols add to the complexity and difficulty of reverse engineering Rust binaries.Therefore, reverse engineers trying to study Rust applications must spend considerable effort and use advanced analysis techniques to accurately reconstruct the logic of the program. As Rust gains popularity in systems programming and security-critical areas, it is critical to recognize and understand the barriers to reverse engineering Rust applications." } ]
