<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="The Difficulty of Reverse Engineering Applications Written in Rust" /><meta property="og:locale" content="en" /><meta name="description" content="Reverse engineering is the process of analyzing a software application to understand its inner workings and functionality. It’s usually done for a variety of reasons, such as understanding undocumented systems, detecting vulnerabilities, or creating compatible software. But reverse engineering becomes quite challenging when it comes to applications written in Rust. This article aims to explain the reasons behind the difficulty of reverse engineering Rust applications. Memory Safety and Ownership Model Rust is a systems programming language that prioritizes memory safety and eliminates common programming errors like null pointer dereferences, buffer overflows, and data races. This is achieved through its unique ownership model and borrow checker, which enforces strict rules on how data is accessed and modified. As a result, Rust programs are inherently more resilient against memory-related vulnerabilities and exploitation. When reverse engineering a Rust application, understanding the ownership model and reconstructing the memory layout becomes essential. Rust’s memory management techniques, such as stack and heap allocations, lifetimes, and borrowing, are complex to decipher without the source code. Reverse engineers need to reconstruct these ownership relationships and memory management patterns accurately, which can be time-consuming and error-prone. Abstraction and Compiler Optimizations Rust provides high-level abstractions without compromising performance. It offers powerful features like pattern matching, algebraic data types, and iterators, which enable expressive and concise code. However, these abstractions are compiled down to low-level machine code, making it challenging to trace back the original intent from the compiled binary. Furthermore, the Rust compiler applies aggressive optimizations to generate efficient code. These optimizations include inlining functions, eliminating dead code, and reordering instructions. While these optimizations enhance performance, they also obfuscate the binary, making it harder to understand the control flow, variable assignments, and function boundaries during reverse engineering. Strong Type System and Enumerations Rust employs a strong type system that ensures memory safety and prevents type-related errors. The type system is expressive and allows developers to define complex data structures using enumerations (enums). Enums are particularly challenging to reverse engineer because they can represent different states and variations of data within a single type. Deciphering the meaning and purpose of enums in a Rust binary requires extensive analysis of memory layouts, function calls, and control flow. Reverse engineers need to identify the different enum variants, understand the associated data, and reconstruct their relationships accurately. Lack of Symbolic Information Symbolic information, such as function names, variable names, and data structures, is crucial for understanding the behavior of a program during reverse engineering. However, Rust’s default compilation process, known as “stripping symbols,” removes most of this information from the compiled binary. This significantly hampers the reverse engineer’s ability to comprehend the code’s intent, leading to a more challenging and time-consuming reverse engineering process. Reverse engineers often rely on dynamic analysis techniques like debugging and dynamic binary instrumentation to extract symbolic information from a running program. However, even with these techniques, reconstructing high-level abstractions and program logic from a Rust binary remains considerably difficult. Conclusion Reverse engineering applications written in Rust present unique challenges because of the language’s emphasis on memory safety, type system, and lack of symbolic information. The ownership pattern, compiler optimizations, strong type system, and stripped symbols add to the complexity and difficulty of reverse engineering Rust binaries. Therefore, reverse engineers trying to study Rust applications must spend considerable effort and use advanced analysis techniques to accurately reconstruct the logic of the program. As Rust gains popularity in systems programming and security-critical areas, it is critical to recognize and understand the barriers to reverse engineering Rust applications." /><meta property="og:description" content="Reverse engineering is the process of analyzing a software application to understand its inner workings and functionality. It’s usually done for a variety of reasons, such as understanding undocumented systems, detecting vulnerabilities, or creating compatible software. But reverse engineering becomes quite challenging when it comes to applications written in Rust. This article aims to explain the reasons behind the difficulty of reverse engineering Rust applications. Memory Safety and Ownership Model Rust is a systems programming language that prioritizes memory safety and eliminates common programming errors like null pointer dereferences, buffer overflows, and data races. This is achieved through its unique ownership model and borrow checker, which enforces strict rules on how data is accessed and modified. As a result, Rust programs are inherently more resilient against memory-related vulnerabilities and exploitation. When reverse engineering a Rust application, understanding the ownership model and reconstructing the memory layout becomes essential. Rust’s memory management techniques, such as stack and heap allocations, lifetimes, and borrowing, are complex to decipher without the source code. Reverse engineers need to reconstruct these ownership relationships and memory management patterns accurately, which can be time-consuming and error-prone. Abstraction and Compiler Optimizations Rust provides high-level abstractions without compromising performance. It offers powerful features like pattern matching, algebraic data types, and iterators, which enable expressive and concise code. However, these abstractions are compiled down to low-level machine code, making it challenging to trace back the original intent from the compiled binary. Furthermore, the Rust compiler applies aggressive optimizations to generate efficient code. These optimizations include inlining functions, eliminating dead code, and reordering instructions. While these optimizations enhance performance, they also obfuscate the binary, making it harder to understand the control flow, variable assignments, and function boundaries during reverse engineering. Strong Type System and Enumerations Rust employs a strong type system that ensures memory safety and prevents type-related errors. The type system is expressive and allows developers to define complex data structures using enumerations (enums). Enums are particularly challenging to reverse engineer because they can represent different states and variations of data within a single type. Deciphering the meaning and purpose of enums in a Rust binary requires extensive analysis of memory layouts, function calls, and control flow. Reverse engineers need to identify the different enum variants, understand the associated data, and reconstruct their relationships accurately. Lack of Symbolic Information Symbolic information, such as function names, variable names, and data structures, is crucial for understanding the behavior of a program during reverse engineering. However, Rust’s default compilation process, known as “stripping symbols,” removes most of this information from the compiled binary. This significantly hampers the reverse engineer’s ability to comprehend the code’s intent, leading to a more challenging and time-consuming reverse engineering process. Reverse engineers often rely on dynamic analysis techniques like debugging and dynamic binary instrumentation to extract symbolic information from a running program. However, even with these techniques, reconstructing high-level abstractions and program logic from a Rust binary remains considerably difficult. Conclusion Reverse engineering applications written in Rust present unique challenges because of the language’s emphasis on memory safety, type system, and lack of symbolic information. The ownership pattern, compiler optimizations, strong type system, and stripped symbols add to the complexity and difficulty of reverse engineering Rust binaries. Therefore, reverse engineers trying to study Rust applications must spend considerable effort and use advanced analysis techniques to accurately reconstruct the logic of the program. As Rust gains popularity in systems programming and security-critical areas, it is critical to recognize and understand the barriers to reverse engineering Rust applications." /><link rel="canonical" href="https://kuzey.rs/posts/ReverseRust/" /><meta property="og:url" content="https://kuzey.rs/posts/ReverseRust/" /><meta property="og:site_name" content="Cyber Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-29T00:21:00+03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The Difficulty of Reverse Engineering Applications Written in Rust" /><meta name="twitter:site" content="@kuzeyardabulut" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-29T00:21:00+03:00","datePublished":"2023-05-29T00:21:00+03:00","description":"Reverse engineering is the process of analyzing a software application to understand its inner workings and functionality. It’s usually done for a variety of reasons, such as understanding undocumented systems, detecting vulnerabilities, or creating compatible software. But reverse engineering becomes quite challenging when it comes to applications written in Rust. This article aims to explain the reasons behind the difficulty of reverse engineering Rust applications. Memory Safety and Ownership Model Rust is a systems programming language that prioritizes memory safety and eliminates common programming errors like null pointer dereferences, buffer overflows, and data races. This is achieved through its unique ownership model and borrow checker, which enforces strict rules on how data is accessed and modified. As a result, Rust programs are inherently more resilient against memory-related vulnerabilities and exploitation. When reverse engineering a Rust application, understanding the ownership model and reconstructing the memory layout becomes essential. Rust’s memory management techniques, such as stack and heap allocations, lifetimes, and borrowing, are complex to decipher without the source code. Reverse engineers need to reconstruct these ownership relationships and memory management patterns accurately, which can be time-consuming and error-prone. Abstraction and Compiler Optimizations Rust provides high-level abstractions without compromising performance. It offers powerful features like pattern matching, algebraic data types, and iterators, which enable expressive and concise code. However, these abstractions are compiled down to low-level machine code, making it challenging to trace back the original intent from the compiled binary. Furthermore, the Rust compiler applies aggressive optimizations to generate efficient code. These optimizations include inlining functions, eliminating dead code, and reordering instructions. While these optimizations enhance performance, they also obfuscate the binary, making it harder to understand the control flow, variable assignments, and function boundaries during reverse engineering. Strong Type System and Enumerations Rust employs a strong type system that ensures memory safety and prevents type-related errors. The type system is expressive and allows developers to define complex data structures using enumerations (enums). Enums are particularly challenging to reverse engineer because they can represent different states and variations of data within a single type. Deciphering the meaning and purpose of enums in a Rust binary requires extensive analysis of memory layouts, function calls, and control flow. Reverse engineers need to identify the different enum variants, understand the associated data, and reconstruct their relationships accurately. Lack of Symbolic Information Symbolic information, such as function names, variable names, and data structures, is crucial for understanding the behavior of a program during reverse engineering. However, Rust’s default compilation process, known as “stripping symbols,” removes most of this information from the compiled binary. This significantly hampers the reverse engineer’s ability to comprehend the code’s intent, leading to a more challenging and time-consuming reverse engineering process. Reverse engineers often rely on dynamic analysis techniques like debugging and dynamic binary instrumentation to extract symbolic information from a running program. However, even with these techniques, reconstructing high-level abstractions and program logic from a Rust binary remains considerably difficult. Conclusion Reverse engineering applications written in Rust present unique challenges because of the language’s emphasis on memory safety, type system, and lack of symbolic information. The ownership pattern, compiler optimizations, strong type system, and stripped symbols add to the complexity and difficulty of reverse engineering Rust binaries. Therefore, reverse engineers trying to study Rust applications must spend considerable effort and use advanced analysis techniques to accurately reconstruct the logic of the program. As Rust gains popularity in systems programming and security-critical areas, it is critical to recognize and understand the barriers to reverse engineering Rust applications.","headline":"The Difficulty of Reverse Engineering Applications Written in Rust","mainEntityOfPage":{"@type":"WebPage","@id":"https://kuzey.rs/posts/ReverseRust/"},"url":"https://kuzey.rs/posts/ReverseRust/"}</script><title>The Difficulty of Reverse Engineering Applications Written in Rust | Cyber Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Cyber Blog"><meta name="application-name" content="Cyber Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/terminal-icon.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Cyber Blog</a></div><div class="site-subtitle font-italic">Cybersecurity related blogs</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/disclaimer/" class="nav-link"> <i class="fa-fw fas fa-gavel ml-xl-3 mr-xl-3 unloaded"></i> <span>DISCLAIMER</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/kuzeyardabulut" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/kuzeyardabulut" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <a href="https://www.linkedin.com/in/kuzeyardabulut/" aria-label="linkedin" class="order-6" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>The Difficulty of Reverse Engineering Applications Written in Rust</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The Difficulty of Reverse Engineering Applications Written in Rust</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Kuzey Arda Bulut </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, May 29, 2023, 12:21 AM +0300" >May 29, 2023<i class="unloaded">2023-05-29T00:21:00+03:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="586 words">3 min read</span></div></div><div class="post-content"><p>Reverse engineering is the process of analyzing a software application to understand its inner workings and functionality. It’s usually done for a variety of reasons, such as understanding undocumented systems, detecting vulnerabilities, or creating compatible software. But reverse engineering becomes quite challenging when it comes to applications written in Rust. This article aims to explain the reasons behind the difficulty of reverse engineering Rust applications.</p><h2 id="memory-safety-and-ownership-model">Memory Safety and Ownership Model</h2><p>Rust is a systems programming language that prioritizes memory safety and eliminates common programming errors like null pointer dereferences, buffer overflows, and data races. This is achieved through its unique ownership model and borrow checker, which enforces strict rules on how data is accessed and modified. As a result, Rust programs are inherently more resilient against memory-related vulnerabilities and exploitation.</p><p>When reverse engineering a Rust application, understanding the ownership model and reconstructing the memory layout becomes essential. Rust’s memory management techniques, such as stack and heap allocations, lifetimes, and borrowing, are complex to decipher without the source code. Reverse engineers need to reconstruct these ownership relationships and memory management patterns accurately, which can be time-consuming and error-prone.</p><h2 id="abstraction-and-compiler-optimizations">Abstraction and Compiler Optimizations</h2><p>Rust provides high-level abstractions without compromising performance. It offers powerful features like pattern matching, algebraic data types, and iterators, which enable expressive and concise code. However, these abstractions are compiled down to low-level machine code, making it challenging to trace back the original intent from the compiled binary.</p><p>Furthermore, the Rust compiler applies aggressive optimizations to generate efficient code. These optimizations include inlining functions, eliminating dead code, and reordering instructions. While these optimizations enhance performance, they also obfuscate the binary, making it harder to understand the control flow, variable assignments, and function boundaries during reverse engineering.</p><h2 id="strong-type-system-and-enumerations">Strong Type System and Enumerations</h2><p>Rust employs a strong type system that ensures memory safety and prevents type-related errors. The type system is expressive and allows developers to define complex data structures using enumerations (enums). Enums are particularly challenging to reverse engineer because they can represent different states and variations of data within a single type.</p><p>Deciphering the meaning and purpose of enums in a Rust binary requires extensive analysis of memory layouts, function calls, and control flow. Reverse engineers need to identify the different enum variants, understand the associated data, and reconstruct their relationships accurately.</p><h2 id="lack-of-symbolic-information">Lack of Symbolic Information</h2><p>Symbolic information, such as function names, variable names, and data structures, is crucial for understanding the behavior of a program during reverse engineering. However, Rust’s default compilation process, known as “stripping symbols,” removes most of this information from the compiled binary. This significantly hampers the reverse engineer’s ability to comprehend the code’s intent, leading to a more challenging and time-consuming reverse engineering process.</p><p>Reverse engineers often rely on dynamic analysis techniques like debugging and dynamic binary instrumentation to extract symbolic information from a running program. However, even with these techniques, reconstructing high-level abstractions and program logic from a Rust binary remains considerably difficult.</p><h2 id="conclusion">Conclusion</h2><p>Reverse engineering applications written in Rust present unique challenges because of the language’s emphasis on memory safety, type system, and lack of symbolic information. The ownership pattern, compiler optimizations, strong type system, and stripped symbols add to the complexity and difficulty of reverse engineering Rust binaries.</p><p>Therefore, reverse engineers trying to study Rust applications must spend considerable effort and use advanced analysis techniques to accurately reconstruct the logic of the program. As Rust gains popularity in systems programming and security-critical areas, it is critical to recognize and understand the barriers to reverse engineering Rust applications.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/rust/'>Rust</a>, <a href='/categories/memory-safety/'>Memory Safety</a>, <a href='/categories/reverse-engineering/'>Reverse Engineering</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rust/" class="post-tag no-text-decoration" >rust</a> <a href="/tags/reverse-engineering/" class="post-tag no-text-decoration" >reverse engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The Difficulty of Reverse Engineering Applications Written in Rust - Cyber Blog&url=https://kuzey.rs/posts/ReverseRust/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://telegram.me/share?text=The Difficulty of Reverse Engineering Applications Written in Rust - Cyber Blog&url=https://kuzey.rs/posts/ReverseRust/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://kuzey.rs/posts/ReverseRust/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/rust/">rust</a> <a class="post-tag" href="/tags/aws-exam/">aws exam</a> <a class="post-tag" href="/tags/dll-hollowing/">dll hollowing</a> <a class="post-tag" href="/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/tags/guide/">guide</a> <a class="post-tag" href="/tags/kcov/">kcov</a> <a class="post-tag" href="/tags/malware/">malware</a> <a class="post-tag" href="/tags/result/">result</a> <a class="post-tag" href="/tags/reverse-engineering/">reverse engineering</a> <a class="post-tag" href="/tags/s22/">s22</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/RustStomping/"><div class="card-body"> <span class="timeago small" >Jun 11, 2023<i class="unloaded">2023-06-11T00:21:00+03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DLL Hollowing with Rust Language: Stealth Injection</h3><div class="text-muted small"><p> This will be the first blog on this website. I take DLL Hollowing topic for my first blog because I didn’t see any articles about DLL Hollowing with rust-lang so I decided to talk about that. This ...</p></div></div></a></div><div class="card"> <a href="/posts/FuzzS22/"><div class="card-body"> <span class="timeago small" >Apr 8<i class="unloaded">2024-04-08T12:00:00+03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trying to Enable KCOV on Samsung Galaxy S22</h3><div class="text-muted small"><p> In this article, I will talk about the research I did by spending about 1.5 months on the S22 device. The primary purpose of my research was to fuzz the device by compiling the kernel with KCOV, bu...</p></div></div></a></div><div class="card"> <a href="/posts/AWS_Speciality/"><div class="card-body"> <span class="timeago small" >Jun 17, 2023<i class="unloaded">2023-06-17T00:21:00+03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AWS Certified Security - Specialty (SCS-C01) Exam Experiences</h3><div class="text-muted small"><p> I passed the AWS Security Specialty exam about 6 months ago and became the world’s youngest aws expert at the age of 15. Today I would like to tell you about my experience in this difficult process...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/RustStomping/" class="btn btn-outline-primary" prompt="Newer"><p>DLL Hollowing with Rust Language: Stealth Injection</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/kuzeyardabulut">Kuzey Arda Bulut</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/rust/">rust</a> <a class="post-tag" href="/tags/aws-exam/">aws exam</a> <a class="post-tag" href="/tags/dll-hollowing/">dll hollowing</a> <a class="post-tag" href="/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/tags/guide/">guide</a> <a class="post-tag" href="/tags/kcov/">kcov</a> <a class="post-tag" href="/tags/malware/">malware</a> <a class="post-tag" href="/tags/result/">result</a> <a class="post-tag" href="/tags/reverse-engineering/">reverse engineering</a> <a class="post-tag" href="/tags/s22/">s22</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
